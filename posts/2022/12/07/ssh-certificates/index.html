<!doctype html><html lang=en><head><title>SSH Certificates · Heap Overrun
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Joel Goguen"><meta name=description content="/ Controlling access to SSH servers using certificates"><meta name=keywords content="blog,developer,sysadmin,system administrator,personal,firewall,OpenBSD,Linux"><meta property="og:url" content="https://jgoguen.ca/posts/2022/12/07/ssh-certificates/"><meta property="og:site_name" content="Heap Overrun"><meta property="og:title" content="SSH Certificates"><meta property="og:description" content="/ Controlling access to SSH servers using certificates"><meta property="og:locale" content="en_ca"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-07T20:38:20-05:00"><meta property="article:tag" content="SSH"><meta property="article:tag" content="Certificates"><meta property="og:image" content="https://jgoguen.ca/img/logo.jpg"><link rel=canonical href=https://jgoguen.ca/posts/2022/12/07/ssh-certificates/><link rel=preload href=https://jgoguen.ca/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://jgoguen.ca/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://jgoguen.ca/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://jgoguen.ca/css/coder.min.aa5ef26fa979d6793724ae2dbd71efa94fd16cb1c5c7db3b6651f21f9892a5fd.css integrity="sha256-ql7yb6l51nk3JK4tvXHvqU/RbLHFx9s7ZlHyH5iSpf0=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://jgoguen.ca/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://jgoguen.ca/css/style.min.51bc8d573bf8d868a603afccfde7fff4e5ca71d65cbc8ee77d8a514fcc208eba.css integrity="sha256-UbyNVzv42GimA6/M/ef/9OXKcdZcvI7nfYpRT8wgjro=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=https://jgoguen.ca/images/favicon.svg sizes=any><link rel=icon type=image/png href=https://jgoguen.ca/img/favicon_32x32.png sizes=32x32><link rel=icon type=image/png href=https://jgoguen.ca/img/favicon_16x16.png sizes=16x16><link rel=apple-touch-icon href=https://jgoguen.ca/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://jgoguen.ca/images/apple-touch-icon.png><link rel=manifest href=https://jgoguen.ca/site.webmanifest><link rel=mask-icon href=https://jgoguen.ca/images/safari-pinned-tab.svg color=#5bbad5><link rel=me href=https://hachyderm.io/@jgoguen><meta name=robots content="noai, noimageai"><meta name=CCBot content="nofollow"><meta name=tdm-reservation content="1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"SSH Certificates","headline":"SSH Certificates","alternativeHeadline":"","description":"\/ Controlling access to SSH servers using certificates","inLanguage":"en-ca","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https://jgoguen.ca/posts/2022/12/07/ssh-certificates/"},"author":{"@type":"Person","name":"Joel Goguen","url":"https://jgoguen.ca/about"},"copyrightHolder":"Heap Overrun","copyrightYear":"2022","dateCreated":"2022-12-07T00:00:00.00Z","datePublished":"2022-12-07T00:00:00.00Z","dateModified":"2024-12-07T20:38:20.00Z","publisher":{"@type":"Organization","name":"Heap Overrun","url":"https://jgoguen.ca/","logo":{"@type":"ImageObject","url":"https://jgoguen.ca/img/logo.jpg","width":"32","height":"32"}},"image":"https://jgoguen.ca/img/logo.jpg","url":"https://jgoguen.ca/posts/2022/12/07/ssh-certificates/","wordCount":"2808","genre":["SSH","certificates"],"keywords":[]}</script></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=scroll-to-top class=hidden><i class="fa fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://jgoguen.ca/>Heap Overrun
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://jgoguen.ca/about>About Me</a></li><li class=navigation-item><a class=navigation-link href=https://jgoguen.ca/docs/resume.pdf>Résumé</a></li><li class=navigation-item><a class=navigation-link href=https://jgoguen.ca/posts>Posts</a></li><li class=navigation-item><a class=navigation-link href=https://jgoguen.ca/contact>Contact Me</a></li></ul></section></nav><div class=content><div id=progress-bar class=hidden aria-hidden=true></div><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://jgoguen.ca/posts/2022/12/07/ssh-certificates/>SSH Certificates</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-12-07T00:00:00Z>December 7, 2022
</time></span><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2024-12-07T20:38:20-05:00>Updated: December 7, 2024
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
14-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=https://jgoguen.ca/tags/ssh/>SSH</a>
</span><span class=separator>•</span>
<span class=tag><a href=https://jgoguen.ca/tags/certificates/>Certificates</a></span></div></div></header><div><p>If you have a SSH server, you&rsquo;ve probably heard that you should be using SSH key
authentication instead of passwords. There&rsquo;s a lot of benefits to key
authentication: better experience, smooth login, ability to log in via scripts,
service accounts become possible, and keys are significantly harder to crack
than a password. But if you deal with a lot of servers, or you manage a lot of
users, or both, there&rsquo;s a better way using SSH certificates instead of simple
keys.</p><p>When using simple key authentication, any user can generate their own SSH keys
and add the public portion to their <code>authorized_keys</code> file if you haven&rsquo;t taken
care to restrict access to it (or if they have broad <code>sudo</code>/<code>doas</code> privileges).
Depending on what other protections you have in place, this can mean users could
access servers from devices they shouldn&rsquo;t be allowed to use. In an enterprise
environment, for example, you may have Internet-exposed SSH servers you want to
restrict to access from managed devices only. Or you may want to allow some
users to log in as either themselves or as other users on the system, which
requires copying the public portion of a key to multiple <code>authorized_keys</code>
files. These keys also don&rsquo;t expire, and need to be manually removed when a user
should no longer have access.</p><p>You may also want to give users some way to trust that they&rsquo;re connecting to
a trusted server without making them compare fingerprints. Normally, you would
need to distribute a list of valid server fingerprints to everyone, and make
sure they get an updated list every time a new server is added, or an existing
server is reinstalled.</p><p>The solution to both problems is an SSH certificate. Functionally similar to
a TLS certificate, SSH certificates can be used for both identifying a server to
a user and identifying a user to a server. In this post, we&rsquo;ll explore how to
set up your SSH Certificate Authority (CA), how to issue certificates for both
users and hosts, and how to revoke SSH certificates when needed.</p><h1 id=creating-your-ssh-ca>Creating your SSH CA
<a class=heading-link href=#creating-your-ssh-ca><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>The first thing you need to do is create your Certificate Authority keys. Unlike
TLS CAs, SSH CAs don&rsquo;t have the concept of intermediate issuers because you
don&rsquo;t actually have a CA certificat, you only have SSH keys trusted as signing
keys. This means your SSH CA is your root CA and can&rsquo;t be kept offline. If
possible, the private key should always be kept in secure hardware of some kind,
such as a Hardware Security Module (HSM) or local TPM. If you do, you&rsquo;ll need to
first create a private key on the secure storage using the PKCS#11 interface.</p><h2 id=create-a-key-in-secure-hardware>Create a key in Secure Hardware
<a class=heading-link href=#create-a-key-in-secure-hardware><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>First you need to know the PKCS#11 URI of the secure hardware module you want to
use. You can find this with the <code>p11tool</code> command, part of the <code>gnutls-utils</code>
package on CentOS and similar distributions:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#89dceb;font-weight:700>$</span> p11tool <span style=color:#89dceb;font-weight:700>--</span>list<span style=color:#89dceb;font-weight:700>-</span>tokens
</span></span><span style=display:flex><span>Token <span style=color:#fab387>0</span>:
</span></span><span style=display:flex><span>        URL: pkcs11:model<span style=color:#89dceb;font-weight:700>=</span>SuperHSM;manufacturer<span style=color:#89dceb;font-weight:700>=</span>SuperSoft;serial<span style=color:#89dceb;font-weight:700>=</span><span style=color:#fab387>883197678</span>b507ca7;token<span style=color:#89dceb;font-weight:700>=</span>puffy<span style=color:#89dceb;font-weight:700>-</span>hsm
</span></span><span style=display:flex><span>        <span style=color:#fab387>Label</span>: puffy<span style=color:#89dceb;font-weight:700>-</span>hsm
</span></span><span style=display:flex><span>        Type: Super Secure HSM
</span></span><span style=display:flex><span>        Flags: RNG, Requires login
</span></span><span style=display:flex><span>        Manufacturer: SuperSoft
</span></span><span style=display:flex><span>        Model: SuperHSM
</span></span><span style=display:flex><span>        Serial: <span style=color:#fab387>883197678</span>b507ca7
</span></span><span style=display:flex><span>        Module: <span style=color:#89dceb;font-weight:700>/</span>usr<span style=color:#89dceb;font-weight:700>/</span>lib64<span style=color:#89dceb;font-weight:700>/</span>pkcs11<span style=color:#89dceb;font-weight:700>/</span>libsuperhsm2<span style=color:#89dceb;font-weight:700>.</span>so
</span></span></code></pre></div><p>Make note of the URL and the Module, you will need both of these later.</p><p>Now generate a private key for your SSH CA. Since you&rsquo;re storing the private key
in secure hardware you could use one key for all your CAs, or you can use one
key per CA.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#89dceb;font-weight:700>$</span> p11tool <span style=color:#89dceb;font-weight:700>--</span>generate<span style=color:#89dceb;font-weight:700>-</span>privkey<span style=color:#89dceb;font-weight:700>=</span>ecdsa <span style=color:#89dceb;font-weight:700>--</span>sec<span style=color:#89dceb;font-weight:700>-</span>param<span style=color:#89dceb;font-weight:700>=</span>high <span style=color:#89dceb;font-weight:700>--</span>login <span style=color:#89dceb;font-weight:700>--</span>label ssh<span style=color:#89dceb;font-weight:700>-</span>user<span style=color:#89dceb;font-weight:700>-</span>ca <span style=color:#a6e3a1>&#39;pkcs11:model=SuperHSM;manufacturer=SuperSoft;serial=883197678b507ca7;token=puffy-hsm&#39;</span>
</span></span><span style=display:flex><span>warning: no <span style=color:#89dceb;font-weight:700>--</span>outfile was specified <span style=color:#89dceb;font-weight:700>and</span> the generated public key will be printed on screen<span style=color:#89dceb;font-weight:700>.</span>
</span></span><span style=display:flex><span>Generating an EC<span style=color:#89dceb;font-weight:700>/</span>ECDSA key<span style=color:#89dceb;font-weight:700>...</span>
</span></span><span style=display:flex><span>Token <span style=color:#a6e3a1>&#39;puffy-hsm&#39;</span> with URL <span style=color:#a6e3a1>&#39;pkcs11:model=SuperHSM;manufacturer=SuperSoft;serial=883197678b507ca7;token=puffy-hsm&#39;</span> requires user PIN
</span></span><span style=display:flex><span>Enter PIN:
</span></span><span style=display:flex><span><span style=color:#89dceb;font-weight:700>-----</span>BEGIN PUBLIC KEY<span style=color:#89dceb;font-weight:700>-----</span>
</span></span><span style=display:flex><span>MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEmbX149h8eCyhg3Sx1DBPVjdW0jP<span style=color:#89dceb;font-weight:700>+</span>
</span></span><span style=display:flex><span>gCeB33mr<span style=color:#89dceb;font-weight:700>/</span>I2vv9EOgr1Ec<span style=color:#89dceb;font-weight:700>/</span>lEablY2D<span style=color:#89dceb;font-weight:700>/</span>PR<span style=color:#89dceb;font-weight:700>+</span>AbZ7wII5aMAp9<span style=color:#89dceb;font-weight:700>+</span><span style=color:#fab387>9</span>vdiaTVTxw<span style=color:#89dceb;font-weight:700>==</span>
</span></span><span style=display:flex><span><span style=color:#89dceb;font-weight:700>-----</span>END PUBLIC KEY<span style=color:#89dceb;font-weight:700>-----</span>
</span></span></code></pre></div><p>This is not the public key you want to save! You need the public key in the
standard SSH format. To get that, run <code>ssh-keygen -D libsuperhsm2.so -e >ssh-ca.pub</code>.
You will use this later when issuing SSH certificates.</p><h2 id=create-a-key-on-disk>Create a key on disk
<a class=heading-link href=#create-a-key-on-disk><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If you don&rsquo;t have secure hardware available, you will need to store your private
keys on disk. These will allow anyone with access to create new certificates
trusted by all your devices, so be sure to appropriately protect them!</p><p>Creating a private key on disk is a matter of a single command:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ssh-keygen -t ecdsa -b 521 -f ssh-ca -C &#39;SSH CA Certificate&#39;
</span></span><span style=display:flex><span>Generating public/private ecdsa key pair.
</span></span><span style=display:flex><span>Enter passphrase (empty for no passphrase):
</span></span><span style=display:flex><span>Enter same passphrase again:
</span></span><span style=display:flex><span>Your identification has been saved in ssh-ca.
</span></span><span style=display:flex><span>Your public key has been saved in ssh-ca.pub.
</span></span><span style=display:flex><span>The key fingerprint is:
</span></span><span style=display:flex><span>SHA256:B6Sms0weOZLIOz/TRV3xZj/vxznRxfC7eVyGY9y+5/c SSH CA Certificate
</span></span><span style=display:flex><span>The key&#39;s randomart image is:
</span></span><span style=display:flex><span>+---[ECDSA 521]---+
</span></span><span style=display:flex><span>|        .  ..    |
</span></span><span style=display:flex><span>|       o   .. .  |
</span></span><span style=display:flex><span>|      o o .  + + |
</span></span><span style=display:flex><span>|.. . + . o  o . +|
</span></span><span style=display:flex><span>|..o B . S .  . =+|
</span></span><span style=display:flex><span>|  .= = . .    =oB|
</span></span><span style=display:flex><span>| o  = .      . *B|
</span></span><span style=display:flex><span>|  oo .         *O|
</span></span><span style=display:flex><span>|   .o          oE|
</span></span><span style=display:flex><span>+----[SHA256]-----+
</span></span></code></pre></div><p>This will create two files: <code>ssh-ca</code> (the private key) and <code>ssh-ca.pub</code> (the
public key). You should create one set of keys for each SSH CA you intend to use;
this usually means creating two sets of keys, one for host certificates and one
for user certificates.</p><h1 id=signing-a-host-certificate>Signing a Host Certificate
<a class=heading-link href=#signing-a-host-certificate><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Now that you have your CA keys created, you&rsquo;re ready to issue SSH certificates.
The first type we&rsquo;ll look at is a host certificate, which identifies a SSH
server to a connecting client. All you need is your SSH server&rsquo;s host public key,
stored in <code>/etc/ssh/ssh_host_*_key.pub</code>, and the keys generated earlier.</p><h2 id=signing-with-pkcs11>Signing with PKCS#11
<a class=heading-link href=#signing-with-pkcs11><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To sign with a private key stored in secure hardware, use the <code>-D</code> option to
<code>ssh-keygen</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ssh-keygen -s ssh-ca.pub -D libsuperhsm2.so -I dev1234.example.com -h -n dev1234.example.com,dev1234,10.20.0.134 -V +52w -z $(date +%s) ./ssh_host_ecdsa_key.pub
</span></span><span style=display:flex><span>Enter PIN for &#39;puffy-hsm&#39;:
</span></span><span style=display:flex><span>Signed host key ./ssh_host_ecdsa_key-cert.pub: id &#34;dev1234.example.com&#34; serial 1670459268 for dev1234.example.com,dev1234,10.20.0.134 valid from 2022-12-05T22:45:00 to 2023-12-04T22:46:02
</span></span></code></pre></div><p>Let&rsquo;s break that command down a bit. Each option means:</p><ul><li><code>-s ssh-ca.pub</code>: Use <code>ssh-ca.pub</code> as the SSH public key</li><li><code>-D libsuperhsm2.so</code>: Look for the private key using the PKCS#11 library
<code>libsuperhsm2.so</code></li><li><code>-I dev1234.example.com</code>: The certificate&rsquo;s identity. This can be any
alphanumeric string, but it&rsquo;s typically best to use the server&rsquo;s hostname.</li><li><code>-h</code>: Create a host certificate.</li><li><code>-n dev1234.example.com,dev1234,10.20.0.134</code>: A comma-separated list of
principals the certificate is valid for. For a host certificate, these are all
the hostnames or IP addresses valid for connecting to the server.</li><li><code>-V +52w</code>: The certificte is valid for the specified time, in this case for
the next 52 weeks.</li><li><code>-z $(date +%s)</code>: Set the certificate serial number. <code>date +%s</code> prints the
current time as seconds since the UNIX epoch, which causes the certificate
serial number to be set to the current time. You don&rsquo;t need this option, but
it can sometimes be helpful to have a serial number defined. If you don&rsquo;t set
a serial number, 0 will be used.</li><li><code>./ssh_host_ecdsa_key.pub</code>: The path to the host public key to sign.</li></ul><h2 id=signing-with-on-disk-keys>Signing with on-disk keys
<a class=heading-link href=#signing-with-on-disk-keys><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To sign with a private key stored on disk, leave out the <code>-D</code> option and pass
the private key to <code>-s</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ssh-keygen -s ssh-ca -I dev1234.example.com -h -n dev1234.example.com,dev1234,10.20.0.134 -V +52w -z $(date +%s) ./ssh_host_ecdsa_key.pub
</span></span><span style=display:flex><span>Signed host key ./ssh_host_ecdsa_key-cert.pub: id &#34;dev1234.example.com&#34; serial 1670459268 for dev1234.example.com,dev1234,10.20.0.134 valid from 2022-12-05T22:45:00 to 2023-12-04T22:46:02
</span></span></code></pre></div><h2 id=using-the-host-certificate>Using the host certificate
<a class=heading-link href=#using-the-host-certificate><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Once you&rsquo;ve generated a host SSH certificate, you need to tell <code>sshd</code> to use it.
Add this line to <code>/etc/ssh/sshd_config</code> and restart <code>sshd</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>HostCertificate /etc/ssh/ssh_host_ecdsa_key-cert.pub
</span></span></code></pre></div><p>Now your SSH server is configured to present a host certificate, so the last
step is to tell clients to trust the certificate. Start by generating the
<code>known_hosts</code> format file:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ printf &#39;@cert-authority *.example.com %s&#39; &#34;$(cat ssh-ca.pub)&#34; &gt;ssh_known_hosts
</span></span></code></pre></div><p>Copy <code>ssh_known_hosts</code> to clients who should trust the SSH host certificates as
<code>/etc/ssh/ssh_known_hosts</code>. After that, you can remove any entries in the user&rsquo;s
<code>known_hosts</code> file for the server; they will automatically trust it based on the
SSH host certificate. And when you eventually reinstall a host, as long as you
sign a new SSH host certificate for the host users won&rsquo;t see the dreaded
&ldquo;WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!&rdquo; message.</p><h1 id=signing-a-user-certificate>Signing a User Certificate
<a class=heading-link href=#signing-a-user-certificate><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Once you have SSH host certificates deployed, the next step is to use SSH user
certificates to identify users to servers. The commands to do so are similar to
host certificates. You will also need the public portion of the user&rsquo;s SSH key.</p><h2 id=signing-with-pkcs11-1>Signing with PKCS#11
<a class=heading-link href=#signing-with-pkcs11-1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To sign a user certificate with a key stored in secure hardware, we once again
use the <code>-D</code> option to <code>ssh-keygen</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ssh-keygen -s ssh-ca.pub -D libsuperhsm2.so -I jgoguen@example.com -n jgoguen,deploybot -V +2w -z $(date +%s) ./user.pub
</span></span><span style=display:flex><span>Enter PIN for &#39;puffy-hsm&#39;:
</span></span><span style=display:flex><span>Signed user key ./user-cert.pub: id &#34;jgoguen@example.com&#34; serial 1670459268 for jgoguen,deploybot valid from 2022-12-06T23:06:00 to 2022-12-20T23:07:00
</span></span></code></pre></div><p>Let&rsquo;s break that command down. Each option means:</p><ul><li><code>-s ssh-ca.pub</code>: Use <code>ssh-ca.pub</code> as the SSH public key</li><li><code>-D libsuperhsm2.so</code>: Look for the private key using the PKCS#11 library
<code>libsuperhsm2.so</code></li><li><code>-I jgoguen@example.com</code>: The certificate&rsquo;s identity. This can be any
alphanumeric string, but it&rsquo;s typically best to use some unique identifier for
the user. Their email address, username, or userPrincipalName are all good
choices.</li><li><code>-n jgoguen,deploybot</code>: A comma-separated list of
principals the certificate is valid for. This allows the user to log in to any
host accepting the certificate as either <code>jgoguen</code> or <code>deploybot</code>.</li><li><code>-V +2w</code>: The certificte is valid for the specified time, in this case for
the next 2 weeks.</li><li><code>-z $(date +%s)</code>: Set the certificate serial number. <code>date +%s</code> prints the
current time as seconds since the UNIX epoch, which causes the certificate
serial number to be set to the current time. You don&rsquo;t need this option, but
it can sometimes be helpful to have a serial number defined. If you don&rsquo;t set
a serial number, 0 will be used.</li><li><code>./jgoguen.pub</code>: The path to the user public key to sign.</li></ul><h2 id=signing-with-on-disk-keys-1>Signing with on-disk keys
<a class=heading-link href=#signing-with-on-disk-keys-1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Again, this is similar to how a host certificate is signed.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ssh-keygen -s ssh-ca -I jgoguen@example.com -n jgoguen,deploybot -V +2w -z $(date +%s) ./user.pub
</span></span><span style=display:flex><span>Signed user key ./user-cert.pub: id &#34;jgoguen@example.com&#34; serial 1670459268 for jgoguen,deploybot valid from 2022-12-06T23:06:00 to 2022-12-20T23:07:00
</span></span></code></pre></div><p>Once again, the options are the same as for signing with a PKCS#11 key except
that the <code>-s</code> option points to the private key to use for signing.</p><h2 id=using-the-user-certificate>Using the user certificate
<a class=heading-link href=#using-the-user-certificate><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To use the user certificate, first all servers must be updated to trust the user
CA signing key. Copy the contents of the CA public key (in this example,
<code>ssh-ca.pub</code>) to all servers as <code>/etc/ssh/user-ca.pub</code>. Then add this line to
<code>/etc/sshd/sshd_config</code> on all servers that should accept SSH certificate
authentication and restart <code>sshd</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>TrustedUserCAKeys /etc/ssh/user-ca.pub
</span></span></code></pre></div><p>Next, deliver the file <code>user-cert.pub</code> to the user&rsquo;s client device. This can be
stored in their <code>~/.ssh</code> directory. The <code>ssh</code> command will expect to find three
files: <code>user</code> (unless the user&rsquo;s private key is stored in a PKCS#11 store),
<code>user.pub</code>, and <code>user-cert.pub</code>. In either <code>/etc/ssh/ssh_config</code> or
<code>~/.ssh/config</code>, set the <code>IdentityFile</code> directive to point to the private key
file or set the <code>PKCS11Provider</code> directive to point to the PKCS#11 library used
to store the private key.</p><h1 id=trust-but-verify>Trust But Verify
<a class=heading-link href=#trust-but-verify><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Verifying that SSH certificates are in use is as simple as watching the logs of
your SSH server. On a modern Linux distribution with <code>systemd</code>, that can be done
with <code>journalctl -f -u sshd.service</code>. For a successful login, you&rsquo;ll see
something like this in the SSH server logs:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sshd[52436]: Accepted publickey for deploybot from 10.20.30.40 port 9923 ssh2: ECDSA-CERT ID jgoguen@example.com (serial 1670459268) CA ECDSA SHA256:tltbnMalWg+skhm+VlGLd2xHiVPozyuOPl34WypdEO0
</span></span></code></pre></div><p>If the user tries to log in with a different username, you&rsquo;ll instead see
something like this:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sshd[52436]: error: key_cert_check_authority: invalid certificate
</span></span><span style=display:flex><span>sshd[52436]: error: Certificate invalid: name is not a listed principal
</span></span></code></pre></div><p>And if the certificate is expired:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sshd[52436]: error: key_cert_check_authority: invalid certificate
</span></span><span style=display:flex><span>sshd[52436]: error: Certificate invalid: expired
</span></span></code></pre></div><h1 id=beyond-the-basics>Beyond The Basics
<a class=heading-link href=#beyond-the-basics><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Now that you have SSH cetificates deployed and in use, there&rsquo;s a lot more you
can do. Here&rsquo;s a few ideas you might want to consider.</p><h2 id=restrict-ssh-options>Restrict SSH options
<a class=heading-link href=#restrict-ssh-options><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Maybe you don&rsquo;t want to allow users to forward ports through the SSH server, or
you don&rsquo;t want to allow X11 forwarding. If you check <code>man ssh-keygen</code> and look
for the <code>-O</code> flag, you&rsquo;ll see a number of different things you can enforce in
the certificate itself. For example, if you wanted to deny port forwarding and
X11 forwarding, you would add <code>-O no-x11-forwarding -O no-port-forwarding</code> to
the <code>ssh-keygen</code> command used to issue a user certificate:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ssh-keygen -s ssh-ca.pub -D libsuperhsm2.so -I jgoguen@example.com -n jgoguen,deploybot -V +2w -z $(date +%s) -O no-x11-forwarding -O no-port-forwarding ./user.pub
</span></span></code></pre></div><p>You can inspect the newly-issued certificate to verify these options are now set:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$ ssh-keygen -f ./user-cert.pub -L
</span></span><span style=display:flex><span>./user-cert.pub:
</span></span><span style=display:flex><span>        Type: ecdsa-sha2-nistp256-cert-v01@openssh.com user certificate
</span></span><span style=display:flex><span>        Public key: ECDSA-CERT SHA256:yeYf7VNJMtYm1Dr+ZqqZHV3DlPpndqFgeOfNfYWXLGk
</span></span><span style=display:flex><span>        Signing CA: ECDSA SHA256:B6Sms0weOZLIOz/TRV3xZj/vxznRxfC7eVyGY9y+5/c (using ecdsa-sha2-nistp521)
</span></span><span style=display:flex><span>        Key ID: &#34;jgoguen@example.com&#34;
</span></span><span style=display:flex><span>        Serial: 1670460599
</span></span><span style=display:flex><span>        Valid: from 2022-12-07T19:49:00 to 2022-12-21T19:49:59
</span></span><span style=display:flex><span>        Principals:
</span></span><span style=display:flex><span>                jgoguen
</span></span><span style=display:flex><span>                deploybot
</span></span><span style=display:flex><span>        Critical Options: (none)
</span></span><span style=display:flex><span>        Extensions:
</span></span><span style=display:flex><span>                permit-agent-forwarding
</span></span><span style=display:flex><span>                permit-pty
</span></span><span style=display:flex><span>                permit-user-rc
</span></span></code></pre></div><p>The <code>permit-X11-forwarding</code> and <code>permit-port-forwarding</code> options, which are
enabled by default, are not present, so users will not be able to forward ports
or X11 connections.</p><h2 id=enforce-a-bastion-host>Enforce a Bastion Host
<a class=heading-link href=#enforce-a-bastion-host><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>A good way to improve the security of your SSH servers is to simply not expose
them to the Internet in the first place and require all connections to pass
through a bastion host. A bastion host is an otherwise normal SSH server, but
it&rsquo;s the only SSH server exposed to the public Internet. All connections to
other SSH servers are required to originate from the bastion host, and a bastion
host should have a much more locked down configuration. Forcing all connections
through a bastion host requires only two simple <code>Host</code> stanzas in
<code>/etc/ssh/ssh_config</code> or <code>~/.ssh/config</code>. If using private keys stored on disk,
use these stanzas:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Host *.example.com
</span></span><span style=display:flex><span>  ProxyJump ssh-gw.example.com
</span></span><span style=display:flex><span>  IdentityFile ~/.ssh/user
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Host ssh-gw.example.com
</span></span><span style=display:flex><span>  ProxyJump none
</span></span><span style=display:flex><span>  IdentityFile ~/.ssh/user
</span></span></code></pre></div><p>If you&rsquo;re using private keys stored in secure hardware, use these stanzas
instead:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Host *.example.com
</span></span><span style=display:flex><span>  ProxyJump ssh-gw.example.com
</span></span><span style=display:flex><span>  CertificateFile ~/.ssh/user-cert.pub
</span></span><span style=display:flex><span>  # For a PKCS#11 URI, only a subset of path arguments are supported by OpenSSH
</span></span><span style=display:flex><span>  IdentityFile pkcs11:object=ssh-user
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Host ssh-gw.example.com
</span></span><span style=display:flex><span>  ProxyJump none
</span></span><span style=display:flex><span>  CertificateFile ~/.ssh/user-cert.pub
</span></span><span style=display:flex><span>  # For a PKCS#11 URI, only a subset of path arguments are supported by OpenSSH
</span></span><span style=display:flex><span>  IdentityFile pkcs11:object=ssh-user
</span></span></code></pre></div><p>If you add the SSH certificate and key to your local SSH agent, you can skip the
<code>CertificateFile</code> and <code>IdentityFile</code> parameters entirely.</p><h2 id=enforce-certificate-authentication>Enforce certificate authentication
<a class=heading-link href=#enforce-certificate-authentication><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If you previously had public key authentication enabled, using certificates
doesn&rsquo;t change that. Users can still log in with their SSH private keys, and
they can add their own SSH keys to their <code>authorized_keys</code> file to allow them to
log in without using their SSH certificate. Fortunately, putting a stop to this
is a one-line change. In <code>/etc/ssh/sshd_config</code> make sure this line is present
then restart <code>sshd</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>AuthorizedKeysFile none
</span></span></code></pre></div><p>This will prevent <code>sshd</code> from checking for any <code>authorized_keys</code> file anywhere,
effectively removing the ability to log in with standard SSH keys and enforcing
SSH certificates. If you want to go one step further and completely remove the
ability to log in with anything but certificates, also add this line to
<code>/etc/ssh/sshd_config</code> and restart <code>sshd</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>AuthenticationMethods publickey
</span></span></code></pre></div><p>If you do decide to completely remove any other authentication method, you
should keep a &ldquo;break glass&rdquo; user account active that can log in with a password
(and 2-factor authentication if possible).</p><h2 id=allow-alternate-user-login-on-specific-hosts>Allow alternate user login on specific hosts
<a class=heading-link href=#allow-alternate-user-login-on-specific-hosts><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The examples given so far will allow logging in as the <code>deploybot</code> user on any
host where that user exists. You may want to restrict where a user can log in as
<code>deploybot</code> though, such as only allowing users to log in as <code>deploybot</code> on
build test hosts. To achieve this, start by removing <code>deploybot</code> as a principal
on the issued certificate. Then, on every host you want to allow <code>deploybot</code>
logins for, add this line to <code>/etc/ssh/sshd_config</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>AuthorizedPrincipalsFile /etc/ssh/auth_principals/auth_principals_%u
</span></span></code></pre></div><p>Then create the directory <code>/etc/ssh/auth_principals</code> and create the file
<code>/etc/ssh/auth_principals/auth_principals_deploybot</code>. In that file, add the
principals of users allowed to log in as <code>deploybot</code>, one per line. Restart
<code>sshd</code> when finished. Now a user with a certificate that has a principal in this
file can simply log in with <code>ssh deploybot@buildtest1234.example.com</code> but <code>ssh deploybot@dev1234.example.com</code> would fail.</p><h1 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>If you manage large fleets of machines, or you manage many users, SSH
certificates give you a fairly easy way to improve the overall security of your
servers with easier and better access control compared to plain SSH keys or
passwords. One thing that isn&rsquo;t covered here is how to make this scale (doing
this manualy for more than just a few hosts and users will be painful), but even
a simple web service properly secured and authenticated will go a long way to
allowing you to scale at least to a small organization.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2013 -
2025
Joel Goguen
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=https://jgoguen.ca/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=https://jgoguen.ca/js/scrollbar.min.1eea81363c83b9d090626bcfd7b529574d2f1b23ddd40a5c76aea3dfd8810712.js integrity="sha256-HuqBNjyDudCQYmvP17UpV00vGyPd1Apcdq6j39iBBxI="></script></body></html>